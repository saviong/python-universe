# -*- coding: utf-8 -*-
"""01-Milestone Project 2 - Assignment.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qYyjdKqxwQdd_rKd54jYhbPfsOQ3MmI4

___

<a href='https://www.udemy.com/user/joseportilla/'><img src='../Pierian_Data_Logo.png'/></a>
___
<center><em>Content Copyright by Pierian Data</em></center>

# Milestone Project 2 - Blackjack Game
In this milestone project you will be creating a Complete BlackJack Card Game in Python.

Here are the requirements:

* You need to create a simple text-based [BlackJack](https://en.wikipedia.org/wiki/Blackjack) game
* The game needs to have one player versus an automated dealer.
* The player can stand or hit.
* The player must be able to pick their betting amount.
* You need to keep track of the player's total money.
* You need to alert the player of wins, losses, or busts, etc...

And most importantly:

* **You must use OOP and classes in some portion of your game. You can not just use functions in your game. Use classes to help you define the Deck and the Player's hand. There are many right ways to do this, so explore it well!**


Feel free to expand this game. Try including multiple players. Try adding in Double-Down and card splits! Remember to you are free to use any resources you want and as always:

# HAVE FUN!
"""

# random module imported for shuffle function of new cards
import random

#Cards definition, name and values created in Global objects
suits = ('Hearts', 'Diamonds', 'Spades', 'Clubs')
ranks = ('Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Jack', 'Queen', 'King', 'Ace')
values = {'Two':2, 'Three':3, 'Four':4, 'Five':5, 'Six':6, 'Seven':7, 'Eight':8,
            'Nine':9, 'Ten':10, 'Jack':10, 'Queen':10, 'King':10, 'Ace':11}

class Card:

    def __init__(self,suit,rank):
        self.suit = suit
        self.rank = rank
        self.value = values[rank]

    def __str__(self):
        return self.rank + ' of ' + self.suit

class Deck:

    def __init__(self):
        # Note this only happens once upon creation of a new Deck
        self.all_cards = []
        for suit in suits:
            for rank in ranks:
                # This assumes the Card class has already been defined!
                self.all_cards.append(Card(suit,rank))

    def shuffle(self):
        # Note this doesn't return anything
        random.shuffle(self.all_cards)

    def deal_one(self):
        # Note we remove one card from the list of all_cards
        return self.all_cards.pop()

    def __del__(self):
        print('The deck is destroyed!')

class Account:

    # Set up the customised balance
    def __init__(self):
        self.balance = int(input('What is your starting balance for the game?'))
        self.bet_amount = 0

    # Print output for Account class
    def __str__(self):
        return 'Hi! Your current balance is ' + self.balance + '.'

    # Withdraw for the bet
    def place_bet(self):

        bet_check = True

        while bet_check:
            self.bet_amount = int(input('How much do you bet for this time?'))

            try:
                if self.balance >= self.bet_amount:
                    self.balance -= self.bet_amount
                    print(f'Withdrawal Accepted! Your current balance is {self.balance}.')
                    bet_check = False

                else:
                    print(f'Funds Unavailable! Your current balance is {self.balance}. Please place the bet amount below the balance.')

            except ValueError:
                    print('Please enter a valid number.')

  # deposit doubling bet amount when the player wins the game
    def win_deposit(self):
        self.balance += self.bet_amount * 2
        print(f'Congratualtions! You have won! Your current balance is {self.balance}.')
        self.bet_amount = 0 #reset for the next bet

    def draw_deposit(self):
        self.balance += self.bet_amount
        print(f'The game is draw! Deposit returned! Your current balance is {self.balance}.')
        self.bet_amount = 0 #reset for the next bet

    def lose_deposit(self):
        print(f'Sorry! You lose! Your current balance is {self.balance}.')
        self.bet_amount = 0 #reset for the next bet

class Player:

    def __init__(self,name):
        self.name = name
        # A new player has no cards
        self.all_cards = []


    # other classes can call the Player name from Player class.
    def get_name(self):
        return self.name

    def add_cards(self,new_cards):
        self.all_cards.append(new_cards)

    def __str__(self):

        card_details = ', '.join(map(str, self.all_cards))

        return f'Player {self.name} has {len(self.all_cards)} cards having {card_details}'

    def __del__(self):
        print("The current player's information is removed!")

"""The code works because map(str, self.all_cards) successfully converts all card objects to strings, which join() then combines. However, the loop is unnecessary and inefficient.​

How map() Works
The map() function applies str() to each card object in self.all_cards, converting them all to strings at once. It returns an iterator that join() can process directly. The expression ', '.join(map(str, self.all_cards)) converts each card to a string and joins them with commas in a single operation.​

Why the Loop is Redundant
The for loop in your code is completely unnecessary because map(str, self.all_cards) already processes the entire list:​

python
for card in self.all_cards:  # This loop serves no purpose
    card_list = ', '.join(map(str, self.all_cards))  # Processes entire list every iteration
On each iteration, the code recreates card_list by processing the entire self.all_cards list again, overwriting the previous value. After the loop completes, card_list contains the same result as if you had run the join() operation just once outside the loop.​

Better Approach
You should remove the loop entirely and use the same approach as Code 1:

python
def __str__(self):
    card_list = ', '.join(map(str, self.all_cards))
    return f'Player {self.name} has {len(self.all_cards)} cards having {card_list}'
This is functionally equivalent to Code 1's list comprehension [str(card) for card in self.all_cards] but uses map() instead. Both approaches apply str() to each card object and pass the results to join()
"""

class Computer:

    def __init__(self):
        self.name = 'Dealer'
        self.all_cards = []

    def add_cards(self,new_cards):
        self.all_cards.append(new_cards)

    def __str__(self):
        return f'Dealer has {len(self.all_cards)} cards - {self.all_cards[0]} and another card face down!'

    def __del__(self):
        print("The current dealer's information is removed!")

"""### Game running"""

# Game Logic

game_on = True
round_num = 0
player_one_account = Account()

while game_on:

    # New Game Set up
    print('The new game starts now!')

    player_one = Player("One")
    dealer = Computer()

    player_one_account.place_bet()

    new_deck = Deck()
    new_deck.shuffle()

    for x in range(2):
        player_one.add_cards(new_deck.deal_one())
        dealer.add_cards(new_deck.deal_one())

    # Play the game
    round_num += 1
    print(f"Round {round_num}")
    print(player_one)
    print(dealer)

    player_one_total = 0
    dealer_total = 0

    for player_card in player_one.all_cards:
        player_one_total += player_card.value

    print(f'Now your total value is {player_one_total}')

    # Check to see if a player hits or stays:
    player_choice = input('Do you want to Hit or Stay? Enter h or s')

    if player_choice[0].lower() == 'h':
        h = True

    else:
        h = False

    # while a player hits:
    while h:

        player_one.add_cards(new_deck.deal_one())
        print('Player gets 1 more card!')
        print(player_one)

        player_one_total = 0 #reset first for recalculate the whole cards on hand.

        for player_card in player_one.all_cards:
            player_one_total += player_card.value

        print(f'Now your total value is {player_one_total}')

        if player_one_total == 21:
            print('Blackjack!')
            h = False
            break

        if player_one_total > 21 and 'Ace' in player_card.suit:
            player_one_total -= 10
            print('Ace can be either 1 or 11 and now turned into 1')
            print(f'The current total value is {player_one_total}')


        if player_one_total > 21:
            print('Bust!')
            h = False
            break

        player_choice = input('Do you want to Hit or Stay? Enter h or s. ')

        if player_choice.lower() == 'h':
            h = True
            print('Player continues!')

        else:
            h = False
            print("Player stays! Dealer's turn now!")
            break


    for dealer_card in dealer.all_cards:
        dealer_total += dealer_card.value

    print(f"Now dealer's total value is {dealer_total}")


    if dealer_total == 21:
        print('Blackjack!')

    while dealer_total < 17:
        dealer.add_cards(new_deck.deal_one())
        print('dealer gets 1 more card')
        dealer_total = 0 #reset first for recalculate the whole cards on hand.
        for dealer_card in dealer.all_cards:
            dealer_total += dealer_card.value

        print(dealer) # need to be updated later
        print(f'The current total value is {dealer_total}.')

        if dealer_total > 21 and 'Ace' in player_card.suit:
            dealer_total -= 10
            print(f'The current total value is {dealer_total} as Ace can be turned into 1')

    if dealer_total > 21:
        print('Bust!')

# Account settlement after bet
    if dealer_total > 21 and player_one_total > 21:
        print('Both dealer and player bust!')
        player_one_account.draw_deposit()

    elif dealer_total == player_one_total:
        print('Draw!')
        player_one_account.draw_deposit()

    elif dealer_total > 21 and player_one_total <= 21:
        print('Dealer bust! Player win!')
        player_one_account.win_deposit()

    elif player_one_total > 21 and dealer_total <= 21:
        print('Player bust! Dealer win!')
        player_one_account.lose_deposit()

    elif player_one_total > dealer_total:
        print('Player win!')
        player_one_account.win_deposit()

    elif player_one_total < dealer_total:
        print('Dealer win!')
        player_one_account.lose_deposit()

    else:
        print('Draw!')
        player_one_account.draw_deposit()

    # Ask player whether continues to play or stop playing
    new_game = input('Do you want to play again? Y / N?')

    if new_game.upper() == 'Y':
        game_on = True
        del player_one
        del dealer
        del new_deck
        continue

    else:
        game_on = False
        del player_one
        del dealer
        del new_deck
        print('Thanks for playing!')
        break

